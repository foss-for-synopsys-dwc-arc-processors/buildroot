From 8313d759e1b5a5b27875832dc55acd155bb627ba Mon Sep 17 00:00:00 2001
From: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date: Tue, 28 Nov 2017 17:45:44 +0300
Subject: [PATCH 13/46] ARC: hsdk-go cleanup

Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
---
 board/synopsys/hsdk/hsdk-cmd.c | 122 ++++++-----------------------------------
 1 file changed, 17 insertions(+), 105 deletions(-)

diff --git a/board/synopsys/hsdk/hsdk-cmd.c b/board/synopsys/hsdk/hsdk-cmd.c
index 523af6ec69..c13942bd69 100644
--- a/board/synopsys/hsdk/hsdk-cmd.c
+++ b/board/synopsys/hsdk/hsdk-cmd.c
@@ -271,20 +271,6 @@ static int env_process_and_validate(void)
 #define DC_CTRL_CACHE_DISABLE	(1 << 0)
 #define DC_CTRL_INV_MODE_FLUSH	(1 << 6)
 
-/* TODO: move this to "arch/arc/include/asm/arcregs.h" */
-#define AUX_NON_VOLATILE_LIMIT	0x5E
-#define ARC_REG_AUX_DCCM	0x18	/* DCCM Base Addr ARCv2 */
-#define ARC_REG_AUX_ICCM	0x208	/* ICCM Base Addr (ARCv2) */
-#define AUX_VOL			0x5E
-#define AUX_CACHE_LIMIT		0x5D
-
-#define AUX_IDENTITY		4
-
-static inline void nop_instr(void)
-{
-	__asm__ __volatile__("nop");
-}
-
 // TODO: add xCCM runtime check
 static void smp_init_slave_cpu_func(u32 core)
 {
@@ -292,13 +278,13 @@ static void smp_init_slave_cpu_func(u32 core)
 
 	/* ICCM move if exists */
 	if (env_core.iccm[core].val != NO_CCM) {
-		r = ARC_REG_AUX_ICCM;
+		r = ARC_AUX_ICCM_BASE;
 		write_aux_reg(r, env_core.iccm[core].val << APT_SHIFT);
 	}
 
 	/* DCCM move if exists */
 	if (env_core.dccm[core].val != NO_CCM) {
-		r = ARC_REG_AUX_DCCM;
+		r = ARC_AUX_DCCM_BASE;
 		write_aux_reg(r, env_core.dccm[core].val << APT_SHIFT);
 	}
 
@@ -320,8 +306,8 @@ static void init_master_nvlim(void)
 	u32 val = env_common.nvlim.val << APT_SHIFT;
 
 	flush_dcache_all();
-	write_aux_reg(AUX_NON_VOLATILE_LIMIT, val);
-	write_aux_reg(AUX_CACHE_LIMIT, val);
+	write_aux_reg(ARC_AUX_NON_VOLATILE_LIMIT, val);
+	write_aux_reg(AUX_AUX_CACHE_LIMIT, val);
 }
 
 // TODO: !! add my own implementation of flush_dcache_all, invalidate_icache_all
@@ -347,9 +333,9 @@ static void init_master_icache(void)
 		write_aux_reg(ARC_AUX_IC_IVIC, 0x00000001U);
 		/* HS Databook, 5.3.3.2: three NOP's must be inserted inbetween
 		 * invalidate and disable  */
-		nop_instr();
-		nop_instr();
-		nop_instr();
+		__builtin_arc_nop();
+		__builtin_arc_nop();
+		__builtin_arc_nop();
 		/* instruction cache disable */
 		write_aux_reg(ARC_AUX_IC_CTRL, 0x00000001U);
 	}
@@ -393,21 +379,6 @@ static int cleanup_cache_before_go(void)
 }
 
 /* ********************* SMP: START ********************* */
-
-#define ARCNUM_SHIFT	8
-
-static inline u32 get_this_cpu_id(void)
-{
-	u32 val = read_aux_reg(AUX_IDENTITY);
-
-//	val &= GENMASK(15, ARCNUM_SHIFT);
-
-	val &= 0xFF00;
-	val >>= ARCNUM_SHIFT;
-
-	return val;
-}
-
 #define	CREG_BASE	(ARC_PERIPHERAL_BASE + 0x1000)
 #define	CREG_CPU_START	(CREG_BASE + 0x400)
 #define	CPU_START_MASK	0xF
@@ -422,7 +393,7 @@ static int cleanup_before_go(void)
 
 static inline void this_cpu_halt(void)
 {
-	__asm__ __volatile__("flag  1\n");
+	__builtin_arc_flag(1);
 }
 
 static void smp_kick_cpu_x(u32 cpu_id)
@@ -468,7 +439,7 @@ __attribute__((naked, noreturn, flatten)) noinline void hsdk_core_init_f(void)
 				: "m" (stack_ptr)
 				: "memory");
 
-	smp_init_slave_cpu_func(get_this_cpu_id());
+	smp_init_slave_cpu_func(CPU_ID_GET());
 
 	set_data_flag();
 	/* Make sure other cores see written value in memory */
@@ -477,12 +448,12 @@ __attribute__((naked, noreturn, flatten)) noinline void hsdk_core_init_f(void)
 	/* Halt the processor untill the master kick us again */
 	this_cpu_halt();
 
-	nop_instr();
-	nop_instr();
-	nop_instr();
+	__builtin_arc_nop();
+	__builtin_arc_nop();
+	__builtin_arc_nop();
 
 	/* Run our program */
-	((void (*)(void))(env_core.entry[get_this_cpu_id()].val))();
+	((void (*)(void))(env_core.entry[CPU_ID_GET()].val))();
 
 	/* Something went terribly wrong */
 	while (true)
@@ -773,7 +744,7 @@ static void setup_clocks(void)
 static void do_init_claster(void)
 {
 	/* A multi-core ARC HS configuration always includes only one
-	 * AUX_NON_VOLATILE_LIMIT register, which is shared by all the cores. */
+	 * ARC_AUX_NON_VOLATILE_LIMIT register, which is shared by all the cores. */
 	init_master_nvlim();
 
 	init_memory_bridge();
@@ -783,10 +754,10 @@ static void do_init_claster(void)
 
 static int check_master_cpu_id(void)
 {
-	if (get_this_cpu_id() == MASTER_CPU)
+	if (CPU_ID_GET() == MASTER_CPU)
 		return 0;
 
-	pr_err("u-boot runs on non-master cpu with id: %u\n", get_this_cpu_id());
+	pr_err("u-boot runs on non-master cpu with id: %u\n", CPU_ID_GET());
 
 	return -ENOENT;
 }
@@ -838,7 +809,7 @@ static int hsdk_go_run(u32 cpu_start_reg)
 	else
 		this_cpu_halt();
 
-	pr_err("u-boot still runs on cpu [%d]\n", get_this_cpu_id());
+	pr_err("u-boot still runs on cpu [%d]\n", CPU_ID_GET());
 
 	/* We will never return after executing our program if master cpu used
 	 * otherwise halt master cpu manually */
@@ -892,65 +863,6 @@ int bootm_prepare_and_run(u32 entry)
 	return bootm_run(reg);
 }
 
-//static int prepare_and_run(void)
-//{
-//	u32 i, reg;
-//	ulong rate;
-//	int ret;
-//
-//	ret = check_master_cpu_id();
-//	if (ret)
-//		return ret;
-//
-//	ret = env_process_and_validate();
-//	if (ret)
-//		return ret;
-//
-//	for (i = 0; i < NR_CPUS; i++) {
-//		env_core.used[i] = is_cpu_used(i);
-//	}
-//
-//	do_init_slave_cpus();
-//
-//	/* TODO: set frequency, not only read */
-//	soc_clk_ctl("cpu-clk", &rate, false);
-//	soc_clk_ctl("sys-clk", &rate, false);
-//	soc_clk_ctl("ddr-clk", &rate, false);
-//	soc_clk_ctl("tun-clk", &rate, false);
-//
-//	/* A multi-core ARC HS configuration always includes only one
-//	 * AUX_NON_VOLATILE_LIMIT register, which is shared by all the cores. */
-//	init_master_nvlim();
-//
-//	/* Prepare CREG_CPU_START for kicking chosen CPUs */
-//	reg = prepare_cpu_ctart_reg();
-//
-//	do_init_master_cpu();
-//
-//	/* Cleanup caches, disable interrupts */
-//	cleanup_before_go();
-//
-//	if (env_common.halt_on_boot)
-//		this_cpu_halt();
-//
-//	/* Kick chosen CPUs */
-//	writel(reg, (void __iomem *)CREG_CPU_START);
-//
-//	if (env_core.used[MASTER_CPU])
-//		((void (*)(void))(env_core.entry[MASTER_CPU].val))();
-//	else
-//		this_cpu_halt();
-//
-//	pr_err("u-boot still runs on cpu [%d]\n", get_this_cpu_id());
-//
-//	/* We will never return after executing our program if master cpu used
-//	 * otherwise halt master cpu manually */
-//	while (true)
-//		this_cpu_halt();
-//
-//	return 0;
-//}
-
 static int do_hsdk_go(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	/* TODO: delete after release */
-- 
2.11.0

