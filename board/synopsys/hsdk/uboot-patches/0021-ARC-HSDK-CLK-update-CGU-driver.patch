From 26f274628016d0bcfba54e5fcdc73f29937e1d65 Mon Sep 17 00:00:00 2001
From: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date: Fri, 15 Dec 2017 16:52:34 +0300
Subject: [PATCH 21/46] ARC: HSDK: CLK: update CGU driver

Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
---
 drivers/clk/clk-hsdk-cgu.c | 483 ++++++++++++++++++++++++++-------------------
 1 file changed, 285 insertions(+), 198 deletions(-)

diff --git a/drivers/clk/clk-hsdk-cgu.c b/drivers/clk/clk-hsdk-cgu.c
index 048b172bad..047bc14681 100644
--- a/drivers/clk/clk-hsdk-cgu.c
+++ b/drivers/clk/clk-hsdk-cgu.c
@@ -8,60 +8,91 @@
  * License version 2. This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
+
+#define DEBUG
+
 #include <common.h>
 #include <clk-uclass.h>
 #include <div64.h>
 #include <dm.h>
 #include <linux/io.h>
 
-#include "clk-hsdk-cgu-mappings.h"
-
-#define CGU_ARC_PLL_CTRL 0x000 //RW ARC PLL control register
-#define CGU_ARC_PLL_STATUS 0x004 //R ARC PLL status register
-
-#define CGU_SYS_PLL_CTRL 0x010 //RW SYS PLL control register
-#define CGU_SYS_PLL_STATUS 0x014 //R SYS PLL status register
-
-#define CGU_DDR_PLL_CTRL 0x020 //RW DDR PLL control register
-#define CGU_DDR_PLL_STATUS 0x024 //R DDR PLL status register
-
-#define CGU_TUN_PLL_CTRL 0x030 //RW Tunnel PLL control register
-#define CGU_TUN_PLL_STATUS 0x034 //R Tunnel PLL status register
-
-#define CGU_HDMI_PLL_CTRL 0x040 //RW HDMI PLL control register
-#define CGU_HDMI_PLL_STATUS 0x044 //R HDMI PLL status register
-
-#define CGU_ARC_IDIV 0x080 //RW Integer divider register for ARC HS38x4 clock
-
-#define CGU_SYS_IDIV_APB 0x180 //RW Integer divider register for APB clock
-#define CGU_SYS_IDIV_AXI 0x190 //RW Integer divider register for AXI clock
-#define CGU_SYS_IDIV_ETH 0x1A0 //RW Integer divider register for ETH clock
-#define CGU_SYS_IDIV_USB 0x1B0 //RW Integer divider register for USB clock
-#define CGU_SYS_IDIV_SDIO 0x1C0 //RW Integer divider register for SDIO clock
-#define CGU_SYS_IDIV_HDMI 0x1D0 //RW Integer divider register for HDMI clock
-#define CGU_SYS_IDIV_GFX_CORE 0x1E0 //RW Integer divider register for GFX core clock
-#define CGU_SYS_IDIV_GFX_DMA 0x1F0 //RW Integer divider register for GFX dma clock
-#define CGU_SYS_IDIV_GFX_CFG 0x200 //RW Integer divider register for GFX config clock
-#define CGU_SYS_IDIV_DMAC_CORE 0x210 //RW Integer divider register for DMAC clock
-#define CGU_SYS_IDIV_DMAC_CFG 0x220 //RW Integer divider register for DMAC config clock
-#define CGU_SYS_IDIV_SDIO_REF 0x230 //RW Integer divider register for SDIO reference clock
-#define CGU_SYS_IDIV_SPI_REF 0x240 //RW Integer divider register for SPI reference clock
-#define CGU_SYS_IDIV_I2C_REF 0x250 //RW Integer divider register for I2C reference clock
-#define CGU_SYS_IDIV_UART_REF 0x260 //RW Integer divider register for UART reference clock
-#define CGU_SYS_IDIV_EBI_REF 0x270 //RW Integer divider register for EBI reference clock
-
-#define CGU_TUN_IDIV 0x380 //RW Integer divider register for Tunnel clock
-
-#define CGU_HDMI_IDIV_APB 0x480 //RW Integer divider register for HDMI clock
-
-#define CGU_I2S_IDIV_TX 0x580 //RW Integer divider register for I2S TX clock
-#define CGU_I2S_IDIV_RX 0x590 //RW Integer divider register for I2S RX clock
+/*
+ * Synopsys ARC HSDK clock tree.
+ *
+ *   ------------------
+ *   | 33.33 MHz xtal |
+ *   ------------------
+ *            |
+ *            |   -----------
+ *            |-->| ARC PLL |
+ *            |   -----------
+ *            |        |
+ *            |        |-->|CGU_ARC_IDIV|----------->
+ *            |        |-->|CREG_CORE_IF_DIV|------->
+ *            |
+ *            |   --------------
+ *            |-->| SYSTEM PLL |
+ *            |   --------------
+ *            |        |
+ *            |        |-->|CGU_SYS_IDIV_APB|------->
+ *            |        |-->|CGU_SYS_IDIV_AXI|------->
+ *            |        |-->|CGU_SYS_IDIV_*|--------->
+ *            |        |-->|CGU_SYS_IDIV_EBI_REF|--->
+ *            |
+ *            |   --------------
+ *            |-->| TUNNEL PLL |
+ *            |   --------------
+ *            |        |
+ *            |        |-->|CGU_TUN_IDIV|----------->
+ *            |
+ *            |   ------------
+ *            |-->| HDMI PLL |
+ *            |   ------------
+ *            |        |
+ *            |        |-->|CGU_HDMI_IDIV_APB|------>
+ *            |
+ *            |   -----------
+ *            |-->| DDR PLL |
+ *                -----------
+ *                     |
+ *                     |---------------------------->
+ */
 
-////////////////////////
-#define CGU_PLL_CTRL	0x000 /* ARC PLL control register */
-#define CGU_PLL_STATUS	0x004 /* ARC PLL status register */
-#define CGU_PLL_FMEAS	0x008 /* ARC PLL frequency measurement register */
-#define CGU_PLL_MON	0x00C /* ARC PLL monitor register */
+DECLARE_GLOBAL_DATA_PTR;
+
+#define CGU_ARC_IDIV		0x080
+#define CGU_TUN_IDIV		0x380
+#define CGU_HDMI_IDIV_APB	0x480
+#define CGU_SYS_IDIV_APB	0x180
+#define CGU_SYS_IDIV_AXI	0x190
+#define CGU_SYS_IDIV_ETH	0x1A0
+#define CGU_SYS_IDIV_USB	0x1B0
+#define CGU_SYS_IDIV_SDIO	0x1C0
+#define CGU_SYS_IDIV_HDMI	0x1D0
+#define CGU_SYS_IDIV_GFX_CORE	0x1E0
+#define CGU_SYS_IDIV_GFX_DMA	0x1F0
+#define CGU_SYS_IDIV_GFX_CFG	0x200
+#define CGU_SYS_IDIV_DMAC_CORE	0x210
+#define CGU_SYS_IDIV_DMAC_CFG	0x220
+#define CGU_SYS_IDIV_SDIO_REF	0x230
+#define CGU_SYS_IDIV_SPI_REF	0x240
+#define CGU_SYS_IDIV_I2C_REF	0x250
+#define CGU_SYS_IDIV_UART_REF	0x260
+#define CGU_SYS_IDIV_EBI_REF	0x270
+
+#define CGU_IDIV_MASK		0xFF /* All idiv have 8 significant bits */
+
+#define CGU_ARC_PLL		0x0
+#define CGU_SYS_PLL		0x10
+#define CGU_DDR_PLL		0x20
+#define CGU_TUN_PLL		0x30
+#define CGU_HDMI_PLL		0x40
+
+#define CGU_PLL_CTRL		0x000 /* ARC PLL control register */
+#define CGU_PLL_STATUS		0x004 /* ARC PLL status register */
+#define CGU_PLL_FMEAS		0x008 /* ARC PLL frequency measurement register */
+#define CGU_PLL_MON		0x00C /* ARC PLL monitor register */
 
 #define CGU_PLL_CTRL_ODIV_SHIFT		2
 #define CGU_PLL_CTRL_IDIV_SHIFT		4
@@ -85,18 +116,45 @@
 #define CREG_CORE_IF_CLK_DIV_1		0x0
 #define CREG_CORE_IF_CLK_DIV_2		0x1
 
+#define MIN_PLL_RATE			100000000 /* 100 MHz */
 #define PARENT_RATE			33333333 /* fixed clock - xtal */
-////////////////////////
+#define CGU_MAX_CLOCKS			24
 
-#define CGU_ARC_PLL_OFFT	0x0
-#define CGU_SYS_PLL_OFFT	0x10
-#define CGU_DDR_PLL_OFFT	0x20
-#define CGU_TUN_PLL_OFFT	0x30
-#define CGU_HDMI_PLL_OFFT	0x40
+#define CGU_SYS_CLOCKS			16
+#define MAX_AXI_CLOCKS			4
 
-#define CGU_MAX_CLOCKS		24
+struct hsdk_idiv_cfg {
+	u32 oft;
+	u8  val[MAX_AXI_CLOCKS];
+};
 
-#define CGU_IDIV_MASK		0xFF
+struct hsdk_clk_cfg {
+	const u32 clk_rate[MAX_AXI_CLOCKS];
+	const u32 pll_rate[MAX_AXI_CLOCKS];
+	const struct hsdk_idiv_cfg idiv[CGU_SYS_CLOCKS];
+};
+
+static const struct hsdk_clk_cfg axi_clk_cfg = {
+	{ 200000000,	400000000,	600000000,	800000000 },
+	{ 400000000,	400000000,	600000000,	800000000 }, {
+	{ CGU_SYS_IDIV_APB,	 { 2,	2,	3,	4 } },	/* APB */
+	{ CGU_SYS_IDIV_AXI,	 { 2,	1,	1,	1 } },	/* AXI */
+	{ CGU_SYS_IDIV_ETH,	 { 1,	1,	2,	2 } },	/* ETH */
+	{ CGU_SYS_IDIV_USB,	 { 1,	1,	2,	2 } },	/* USB */
+	{ CGU_SYS_IDIV_SDIO,	 { 1,	1,	2,	2 } },	/* SDIO */
+	{ CGU_SYS_IDIV_HDMI,	 { 1,	1,	2,	2 } },	/* HDMI */
+	{ CGU_SYS_IDIV_GFX_CORE, { 1,	1,	2,	2 } },	/* GPU-CORE */
+	{ CGU_SYS_IDIV_GFX_DMA,	 { 1,	1,	2,	2 } },	/* GPU-DMA */
+	{ CGU_SYS_IDIV_GFX_CFG,	 { 2,	2,	3,	4 } },	/* GPU-CFG */
+	{ CGU_SYS_IDIV_DMAC_CORE,{ 1,	1,	2,	2 } },	/* DMAC-CORE */
+	{ CGU_SYS_IDIV_DMAC_CFG, { 2,	2,	3,	4 } },	/* DMAC-CFG */
+	{ CGU_SYS_IDIV_SDIO_REF, { 4,	4,	6,	8 } },	/* SDIO-REF */
+	{ CGU_SYS_IDIV_SPI_REF,	 { 12,	12,	18,	24 } },	/* SPI-REF */
+	{ CGU_SYS_IDIV_I2C_REF,	 { 2,	2,	3,	4 } },	/* I2C-REF */
+	{ CGU_SYS_IDIV_UART_REF, { 12,	12,	18,	24 } },	/* UART-REF */
+	{ CGU_SYS_IDIV_EBI_REF,	 { 8,	8,	12,	16 } }	/* EBI-REF */
+	}
+};
 
 struct hsdk_pll_cfg {
 	u32 rate;
@@ -138,7 +196,7 @@ static const struct hsdk_pll_cfg hdmi_pll_cfg[] = {
 	{}
 };
 
-struct hsdk_pll_clk {
+struct hsdk_cgu_clk {
 	/* CGU block register */
 	void __iomem *cgu_regs;
 	/* CREG block register */
@@ -157,95 +215,107 @@ struct hsdk_pll_clk {
 
 struct hsdk_pll_devdata {
 	const struct hsdk_pll_cfg *pll_cfg;
-	int (*update_rate)(struct hsdk_pll_clk *clk, unsigned long rate,
+	int (*update_rate)(struct hsdk_cgu_clk *clk, unsigned long rate,
 			   const struct hsdk_pll_cfg *cfg);
 };
 
-static int hsdk_pll_core_update_rate(struct hsdk_pll_clk *, unsigned long,
+static int hsdk_pll_core_update_rate(struct hsdk_cgu_clk *, unsigned long,
 				     const struct hsdk_pll_cfg *);
-static int hsdk_pll_comm_update_rate(struct hsdk_pll_clk *, unsigned long,
+static int hsdk_pll_comm_update_rate(struct hsdk_cgu_clk *, unsigned long,
 				     const struct hsdk_pll_cfg *);
 
-static const struct hsdk_pll_devdata core_pll_devdata = {
+static const struct hsdk_pll_devdata core_pll_dat = {
 	.pll_cfg = asdt_pll_cfg,
 	.update_rate = hsdk_pll_core_update_rate,
 };
 
-static const struct hsdk_pll_devdata sdt_pll_devdata = {
+static const struct hsdk_pll_devdata sdt_pll_dat = {
 	.pll_cfg = asdt_pll_cfg,
 	.update_rate = hsdk_pll_comm_update_rate,
 };
 
-static const struct hsdk_pll_devdata hdmi_pll_devdata = {
+static const struct hsdk_pll_devdata hdmi_pll_dat = {
 	.pll_cfg = hdmi_pll_cfg,
 	.update_rate = hsdk_pll_comm_update_rate,
 };
 
+static ulong idiv_set(struct clk *, ulong);
+static ulong cpu_clk_set(struct clk *, ulong);
+static ulong axi_clk_set(struct clk *, ulong);
+static ulong tun_clk_set(struct clk *, ulong);
+static ulong idiv_get(struct clk *);
+static int idiv_off(struct clk *);
+static ulong pll_set(struct clk *, ulong);
+static ulong pll_get(struct clk *);
+
 struct hsdk_cgu_clock_map {
 	u32 cgu_pll_oft;
 	u32 creg_div_oft;
 	u32 cgu_div_oft;
 	const struct hsdk_pll_devdata *pll_devdata;
+	ulong (*get_rate)(struct clk *clk);
+	ulong (*set_rate)(struct clk *clk, ulong rate);
+	int (*disable)(struct clk *clk);
 };
 
 static const struct hsdk_cgu_clock_map clock_map[] = {
-	{ CGU_ARC_PLL_OFFT, 0, 0, &core_pll_devdata }, // CLK_ARC_PLL
-	{ CGU_ARC_PLL_OFFT, 0, CGU_ARC_IDIV, &core_pll_devdata }, // CLK_ARC
-	{ CGU_DDR_PLL_OFFT, 0, 0, &sdt_pll_devdata }, // CLK_DDR_PLL
-	{ CGU_SYS_PLL_OFFT, 0, 0, &sdt_pll_devdata }, // CLK_SYS_PLL
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_APB, &sdt_pll_devdata }, // CLK_SYS_APB
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_AXI, &sdt_pll_devdata }, // CLK_SYS_AXI
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_ETH, &sdt_pll_devdata }, // CLK_SYS_ETH
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_USB, &sdt_pll_devdata }, // CLK_SYS_USB
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_SDIO, &sdt_pll_devdata }, // CLK_SYS_SDIO
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_HDMI, &sdt_pll_devdata }, // CLK_SYS_HDMI
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_GFX_CORE, &sdt_pll_devdata }, // CLK_SYS_GFX_CORE
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_GFX_DMA, &sdt_pll_devdata }, // CLK_SYS_GFX_DMA
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_GFX_CFG, &sdt_pll_devdata }, // CLK_SYS_GFX_CFG
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_DMAC_CORE, &sdt_pll_devdata }, // CLK_SYS_DMAC_CORE
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_DMAC_CFG, &sdt_pll_devdata }, // CLK_SYS_DMAC_CFG
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_SDIO_REF, &sdt_pll_devdata }, // CLK_SYS_SDIO_REF
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_SPI_REF, &sdt_pll_devdata }, // CLK_SYS_SPI_REF
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_I2C_REF, &sdt_pll_devdata }, // CLK_SYS_I2C_REF
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_UART_REF, &sdt_pll_devdata }, // CLK_SYS_UART_REF
-	{ CGU_SYS_PLL_OFFT, 0, CGU_SYS_IDIV_EBI_REF, &sdt_pll_devdata }, // CLK_SYS_EBI_REF
-	{ CGU_TUN_PLL_OFFT, 0, 0, &sdt_pll_devdata }, // CLK_TUN_PLL
-	{ CGU_TUN_PLL_OFFT, 0, CGU_TUN_IDIV, &sdt_pll_devdata }, // CLK_TUN
-	{ CGU_HDMI_PLL_OFFT, 0, 0, &hdmi_pll_devdata }, // CLK_HDMI_PLL
-	{ CGU_HDMI_PLL_OFFT, 0, CGU_HDMI_IDIV_APB, &hdmi_pll_devdata } // CLK_HDMI
+	{ CGU_ARC_PLL, 0, 0, &core_pll_dat, pll_get, pll_set, NULL },
+	{ CGU_ARC_PLL, 0, CGU_ARC_IDIV, &core_pll_dat, idiv_get, cpu_clk_set, idiv_off },	/* special behavior */
+	{ CGU_DDR_PLL, 0, 0, &sdt_pll_dat, pll_get, pll_set, NULL },
+	{ CGU_SYS_PLL, 0, 0, &sdt_pll_dat, pll_get, pll_set, NULL },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_APB, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_AXI, &sdt_pll_dat, idiv_get, axi_clk_set, idiv_off },	/* special behavior */
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_ETH, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_USB, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_SDIO, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_HDMI, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_GFX_CORE, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_GFX_DMA, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_GFX_CFG, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_DMAC_CORE, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_DMAC_CFG, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_SDIO_REF, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_SPI_REF, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_I2C_REF, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_UART_REF, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_SYS_PLL, 0, CGU_SYS_IDIV_EBI_REF, &sdt_pll_dat, idiv_get, idiv_set, idiv_off },
+	{ CGU_TUN_PLL, 0, 0, &sdt_pll_dat, pll_get, pll_set, NULL },
+	{ CGU_TUN_PLL, 0, CGU_TUN_IDIV, &sdt_pll_dat, idiv_get, tun_clk_set, idiv_off },	/* special behavior */
+	{ CGU_HDMI_PLL, 0, 0, &hdmi_pll_dat, pll_get, pll_set, NULL },
+	{ CGU_HDMI_PLL, 0, CGU_HDMI_IDIV_APB, &hdmi_pll_dat, idiv_get, idiv_set, idiv_off }
 };
 
-static inline void hsdk_idiv_write(struct hsdk_pll_clk *clk, u32 val)
+static inline void hsdk_idiv_write(struct hsdk_cgu_clk *clk, u32 val)
 {
 	iowrite32(val, clk->idiv_regs);
 }
 
-static inline u32 hsdk_idiv_read(struct hsdk_pll_clk *clk)
+static inline u32 hsdk_idiv_read(struct hsdk_cgu_clk *clk)
 {
 	return ioread32(clk->idiv_regs);
 }
 
-static inline void hsdk_pll_write(struct hsdk_pll_clk *clk, u32 reg, u32 val)
+static inline void hsdk_pll_write(struct hsdk_cgu_clk *clk, u32 reg, u32 val)
 {
 	iowrite32(val, clk->regs + reg);
 }
 
-static inline u32 hsdk_pll_read(struct hsdk_pll_clk *clk, u32 reg)
+static inline u32 hsdk_pll_read(struct hsdk_cgu_clk *clk, u32 reg)
 {
 	return ioread32(clk->regs + reg);
 }
 
-static inline void hsdk_pll_spcwrite(struct hsdk_pll_clk *clk, u32 reg, u32 val)
+static inline void hsdk_pll_spcwrite(struct hsdk_cgu_clk *clk, u32 reg, u32 val)
 {
 	iowrite32(val, clk->spec_regs + reg);
 }
 
-static inline u32 hsdk_pll_spcread(struct hsdk_pll_clk *clk, u32 reg)
+static inline u32 hsdk_pll_spcread(struct hsdk_cgu_clk *clk, u32 reg)
 {
 	return ioread32(clk->spec_regs + reg);
 }
 
-static inline void hsdk_pll_set_cfg(struct hsdk_pll_clk *clk,
+static inline void hsdk_pll_set_cfg(struct hsdk_cgu_clk *clk,
 				    const struct hsdk_pll_cfg *cfg)
 {
 	u32 val = 0;
@@ -261,22 +331,22 @@ static inline void hsdk_pll_set_cfg(struct hsdk_pll_clk *clk,
 	hsdk_pll_write(clk, CGU_PLL_CTRL, val);
 }
 
-static inline bool hsdk_pll_is_locked(struct hsdk_pll_clk *clk)
+static inline bool hsdk_pll_is_locked(struct hsdk_cgu_clk *clk)
 {
 	return !!(hsdk_pll_read(clk, CGU_PLL_STATUS) & CGU_PLL_STATUS_LOCK);
 }
 
-static inline bool hsdk_pll_is_err(struct hsdk_pll_clk *clk)
+static inline bool hsdk_pll_is_err(struct hsdk_cgu_clk *clk)
 {
 	return !!(hsdk_pll_read(clk, CGU_PLL_STATUS) & CGU_PLL_STATUS_ERR);
 }
 
-static ulong hsdk_pll_get_rate(struct clk *sclk)
+static ulong pll_get(struct clk *sclk)
 {
 	u32 val;
 	u64 rate;
 	u32 idiv, fbdiv, odiv;
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
 
 	val = hsdk_pll_read(clk, CGU_PLL_CTRL);
 
@@ -307,7 +377,7 @@ static unsigned long hsdk_pll_round_rate(struct clk *sclk, unsigned long rate)
 {
 	int i;
 	unsigned long best_rate;
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
 	const struct hsdk_pll_cfg *pll_cfg = clk->pll_devdata->pll_cfg;
 
 	if (pll_cfg[0].rate == 0)
@@ -325,7 +395,7 @@ static unsigned long hsdk_pll_round_rate(struct clk *sclk, unsigned long rate)
 	return best_rate;
 }
 
-static int hsdk_pll_comm_update_rate(struct hsdk_pll_clk *clk,
+static int hsdk_pll_comm_update_rate(struct hsdk_cgu_clk *clk,
 				     unsigned long rate,
 				     const struct hsdk_pll_cfg *cfg)
 {
@@ -345,7 +415,7 @@ static int hsdk_pll_comm_update_rate(struct hsdk_pll_clk *clk,
 	return 0;
 }
 
-static int hsdk_pll_core_update_rate(struct hsdk_pll_clk *clk,
+static int hsdk_pll_core_update_rate(struct hsdk_cgu_clk *clk,
 				     unsigned long rate,
 				     const struct hsdk_pll_cfg *cfg)
 {
@@ -379,11 +449,11 @@ static int hsdk_pll_core_update_rate(struct hsdk_pll_clk *clk,
 	return 0;
 }
 
-static ulong hsdk_pll_set_rate(struct clk *sclk, ulong rate)
+static ulong pll_set(struct clk *sclk, ulong rate)
 {
 	int i;
 	unsigned long best_rate;
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
 	const struct hsdk_pll_cfg *pll_cfg = clk->pll_devdata->pll_cfg;
 
 	best_rate = hsdk_pll_round_rate(sclk, rate);
@@ -395,20 +465,29 @@ static ulong hsdk_pll_set_rate(struct clk *sclk, ulong rate)
 		}
 	}
 
-	pr_err("invalid rate=%ld, parent_rate=%d\n", best_rate, PARENT_RATE);
+	pr_err("invalid rate=%ld Hz, parent_rate=%d Hz\n", best_rate, PARENT_RATE);
 
 	return -EINVAL;
 }
 
-static ulong hsdk_idiv_get_rate(struct clk *sclk)
+static int idiv_off(struct clk *sclk)
 {
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
-	ulong parent_rate = hsdk_pll_get_rate(sclk);
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
+
+	hsdk_idiv_write(clk, 0);
+
+	return 0;
+}
+
+static ulong idiv_get(struct clk *sclk)
+{
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
+	ulong parent_rate = pll_get(sclk);
 	u32 div_factor = hsdk_idiv_read(clk);
 
 	div_factor &= CGU_IDIV_MASK;
 
-	debug("current configurarion: %#x (%d)\n", div_factor, div_factor);
+	pr_debug("current configurarion: %#x (%d)\n", div_factor, div_factor);
 
 	if (div_factor == 0)
 		return 0;
@@ -416,25 +495,91 @@ static ulong hsdk_idiv_get_rate(struct clk *sclk)
 	return parent_rate / div_factor;
 }
 
-static ulong hsdk_idiv_set_rate(struct clk *sclk, ulong rate)
+/* Special behavior: wen we set this clock we set both idiv and pll */
+static ulong cpu_clk_set(struct clk *sclk, ulong rate)
 {
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
-	ulong parent_rate = hsdk_pll_get_rate(sclk);
+	ulong ret;
+
+	ret = pll_set(sclk, rate);
+	idiv_set(sclk, rate);
+
+	return ret;
+}
+
+/* Special behavior: wen we set this clock we set both idiv and pll and all pll dividers */
+static ulong axi_clk_set(struct clk *sclk, ulong rate)
+{
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
+	ulong pll_rate;
+	int i, freq_idx = -1;
+	ulong ret = 0;
+
+	pll_rate = pll_get(sclk);
+
+	for (i = 0; i < MAX_AXI_CLOCKS; i++) {
+		if (axi_clk_cfg.clk_rate[i] == rate) {
+			freq_idx = i;
+			break;
+		}
+	}
+
+	if (freq_idx < 0) {
+		pr_err("axi clk: invalid rate=%ld Hz\n", rate);
+		return -EINVAL;
+	}
+
+	/* configure PLL before dividers */
+	if (axi_clk_cfg.pll_rate[freq_idx] < pll_rate)
+		ret = pll_set(sclk, axi_clk_cfg.pll_rate[freq_idx]);
+
+	/* configure SYS dividers */
+	for (i = 0; i < CGU_SYS_CLOCKS; i++) {
+		clk->idiv_regs = clk->cgu_regs + axi_clk_cfg.idiv[i].oft;
+		hsdk_idiv_write(clk, axi_clk_cfg.idiv[i].val[freq_idx]);
+	}
+
+	/* configure PLL after dividers */
+	if (axi_clk_cfg.pll_rate[freq_idx] >= pll_rate)
+		ret = pll_set(sclk, axi_clk_cfg.pll_rate[freq_idx]);
+
+	return ret;
+}
+
+static ulong tun_clk_set(struct clk *sclk, ulong rate)
+{
+	ulong ret;
+
+	if (rate >= MIN_PLL_RATE)
+		ret = pll_set(sclk, rate);
+	else
+		ret = pll_set(sclk, 150000000);
+
+	idiv_set(sclk, rate);
+
+	return ret;
+}
+
+static ulong idiv_set(struct clk *sclk, ulong rate)
+{
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
+	ulong parent_rate = pll_get(sclk);
 	u32 div_factor;
 
 	div_factor = parent_rate / rate;
-	if (abs(rate - parent_rate / (div_factor + 1)) <= abs(rate - parent_rate / div_factor))
+	if (abs(rate - parent_rate / (div_factor + 1)) <=
+	    abs(rate - parent_rate / div_factor)) {
 		div_factor += 1;
+	}
 
 	if (div_factor & ~CGU_IDIV_MASK) {
-		pr_err("invalid rate=%ld, parent_rate=%ld, div=%d: max divider valie is%d\n",
+		pr_err("invalid rate=%ld Hz, parent_rate=%ld Hz, div=%d: max divider valie is%d\n",
 		       rate, parent_rate, div_factor, CGU_IDIV_MASK);
 
 		div_factor = CGU_IDIV_MASK;
 	}
 
 	if (div_factor == 0) {
-		pr_err("invalid rate=%ld, parent_rate=%ld, div=%d: min divider valie is 1\n",
+		pr_err("invalid rate=%ld Hz, parent_rate=%ld Hz, div=%d: min divider valie is 1\n",
 		       rate, parent_rate, div_factor);
 
 		div_factor = 1;
@@ -445,125 +590,67 @@ static ulong hsdk_idiv_set_rate(struct clk *sclk, ulong rate)
 	return 0;
 }
 
-static void hsdk_prepare_clock_tree_branch(struct clk *sclk)
+static int hsdk_prepare_clock_tree_branch(struct clk *sclk)
 {
-	struct hsdk_pll_clk *clk = dev_get_priv(sclk->dev);
+	struct hsdk_cgu_clk *clk = dev_get_priv(sclk->dev);
+
+	if (sclk->id >= CGU_MAX_CLOCKS)
+		return -EINVAL;
 
 	clk->pll_devdata = clock_map[sclk->id].pll_devdata;
 	clk->regs = clk->cgu_regs + clock_map[sclk->id].cgu_pll_oft;
 	clk->spec_regs = clk->creg_regs + clock_map[sclk->id].creg_div_oft;
 	clk->idiv_regs = clk->cgu_regs + clock_map[sclk->id].cgu_div_oft;
+
+	return 0;
 }
 
 static ulong hsdk_cgu_get_rate(struct clk *sclk)
 {
-//	printf("PAL: %s: id: %ld\n", __func__, sclk->id);
-
-	if (sclk->id >= CGU_MAX_CLOCKS)
+	if (hsdk_prepare_clock_tree_branch(sclk))
 		return -EINVAL;
 
-	hsdk_prepare_clock_tree_branch(sclk);
-
-	switch (sclk->id) {
-		case CLK_ARC_PLL:
-		case CLK_DDR_PLL:
-		case CLK_SYS_PLL:
-		case CLK_TUN_PLL:
-		case CLK_HDMI_PLL:
-			return hsdk_pll_get_rate(sclk);
-			break;
-
-		case CLK_ARC:
-		case CLK_SYS_APB:
-		case CLK_SYS_AXI:
-		case CLK_SYS_ETH:
-		case CLK_SYS_USB:
-		case CLK_SYS_SDIO:
-		case CLK_SYS_HDMI:
-		case CLK_SYS_GFX_CORE:
-		case CLK_SYS_GFX_DMA:
-		case CLK_SYS_GFX_CFG:
-		case CLK_SYS_DMAC_CORE:
-		case CLK_SYS_DMAC_CFG:
-		case CLK_SYS_SDIO_REF:
-		case CLK_SYS_SPI_REF:
-		case CLK_SYS_I2C_REF:
-		case CLK_SYS_UART_REF:
-		case CLK_SYS_EBI_REF:
-		case CLK_TUN:
-		case CLK_HDMI:
-			return hsdk_idiv_get_rate(sclk);
-			break;
-
-		default:
-			pr_err("CLK-ERR: %s: id: %ld: unsupported\n", __func__, sclk->id);
-			break;
-	}
-
-	return 0;
+	return clock_map[sclk->id].get_rate(sclk);
 }
 
 static ulong hsdk_cgu_set_rate(struct clk *sclk, ulong rate)
 {
-//	debug("PAL: %s: id: %ld\n", __func__, sclk->id);
-
-	if (sclk->id >= CGU_MAX_CLOCKS)
+	if (hsdk_prepare_clock_tree_branch(sclk))
 		return -EINVAL;
 
-	hsdk_prepare_clock_tree_branch(sclk);
-
-	switch (sclk->id) {
-		case CLK_ARC_PLL:
-		case CLK_DDR_PLL:
-		case CLK_SYS_PLL:
-		case CLK_TUN_PLL:
-		case CLK_HDMI_PLL:
-			return hsdk_pll_set_rate(sclk, rate);
-			break;
+	return clock_map[sclk->id].set_rate(sclk, rate);
+}
 
-		case CLK_ARC:
-		case CLK_SYS_APB:
-		case CLK_SYS_AXI:
-		case CLK_SYS_ETH:
-		case CLK_SYS_USB:
-		case CLK_SYS_SDIO:
-		case CLK_SYS_HDMI:
-		case CLK_SYS_GFX_CORE:
-		case CLK_SYS_GFX_DMA:
-		case CLK_SYS_GFX_CFG:
-		case CLK_SYS_DMAC_CORE:
-		case CLK_SYS_DMAC_CFG:
-		case CLK_SYS_SDIO_REF:
-		case CLK_SYS_SPI_REF:
-		case CLK_SYS_I2C_REF:
-		case CLK_SYS_UART_REF:
-		case CLK_SYS_EBI_REF:
-		case CLK_TUN:
-		case CLK_HDMI:
-			return hsdk_idiv_set_rate(sclk, rate);
-			break;
+static int hsdk_cgu_disable(struct clk *sclk)
+{
+	if (hsdk_prepare_clock_tree_branch(sclk))
+		return -EINVAL;
 
-		default:
-			pr_err("CLK-ERR: %s: id: %ld: unsupported\n", __func__, sclk->id);
-			break;
-	}
+	if (clock_map[sclk->id].disable)
+		return clock_map[sclk->id].disable(sclk);
 
-	return 0;
+	return -ENOTSUPP;
 }
 
 static const struct clk_ops hsdk_cgu_ops = {
 	.set_rate = hsdk_cgu_set_rate,
 	.get_rate = hsdk_cgu_get_rate,
+	.disable = hsdk_cgu_disable,
 };
 
 static int hsdk_cgu_clk_probe(struct udevice *dev)
 {
-	struct hsdk_pll_clk *pll_clk = dev_get_priv(dev);
+	struct hsdk_cgu_clk *pll_clk = dev_get_priv(dev);
 
 	BUILD_BUG_ON(ARRAY_SIZE(clock_map) != CGU_MAX_CLOCKS);
 
 	pll_clk->cgu_regs = (void __iomem *)devfdt_get_addr_index(dev, 0);
+	if (!pll_clk->cgu_regs)
+		return -EINVAL;
+
 	pll_clk->creg_regs = (void __iomem *)devfdt_get_addr_index(dev, 1);
+	if (!pll_clk->creg_regs)
+		return -EINVAL;
 
 	return 0;
 }
@@ -578,6 +665,6 @@ U_BOOT_DRIVER(hsdk_cgu_clk) = {
 	.id = UCLASS_CLK,
 	.of_match = hsdk_cgu_clk_id,
 	.probe = hsdk_cgu_clk_probe,
-	.platdata_auto_alloc_size = sizeof(struct hsdk_pll_clk),
+	.platdata_auto_alloc_size = sizeof(struct hsdk_cgu_clk),
 	.ops = &hsdk_cgu_ops,
 };
-- 
2.11.0

